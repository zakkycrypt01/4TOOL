const TelegramErrorHandler = require('../utils/telegramErrorHandler');

class SettingsHandlers {
    constructor(bot, db, config, telegramBotManager = null, autonomousService = null) {
        this.bot = bot;
        this.db = db;
        this.config = config;
        this.telegramBotManager = telegramBotManager;
        this.autonomousService = autonomousService;
        // Removed local userStates; use main bot's userStates
        this.lastMessageIds = new Map();
    }

    // Handle input messages for settings-related waiting states
    async handleMessage(ctx, userState) {
        const chatId = ctx.chat.id;
        const telegramId = ctx.from.id.toString();
        const message = ctx.message.text;

        console.log('SettingsHandlers.handleMessage called:', {
            chatId,
            telegramId,
            message,
            userState: userState?.state,
            hasBot: !!this.bot,
            hasDb: !!this.db
        });

        // Safety checks
        if (!this.bot) {
            console.error('Bot instance not available in settings handler');
            return false;
        }
        
        if (!this.db) {
            console.error('Database instance not available in settings handler');
            return false;
        }

        try {
            if (userState && userState.state) {
                console.log('Processing userState:', userState.state);
                switch (userState.state) {
                    case 'waiting_max_trade_amount': {
                        console.log('üîç Processing max trade amount input:', message);
                        const maxAmount = parseFloat(message);
                        console.log('üîç Parsed max amount:', maxAmount);
                        
                        if (isNaN(maxAmount) || maxAmount <= 0) {
                            console.log('‚ùå Invalid max trade amount, sending error message');
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid maximum trade amount (positive number).');
                            return { handled: true, clearState: false };
                        }
                        
                        console.log('üîç Getting user by telegram ID:', telegramId);
                        const user = await this.db.getUserByTelegramId(telegramId);
                        console.log('‚úÖ Found user:', user.id);
                        
                        console.log('üîç Updating user settings with max trade amount:', maxAmount);
                        await this.db.updateUserSettings(user.id, { max_trade_amount: maxAmount });
                        console.log('‚úÖ Settings updated successfully');
                        
                        await this.sendAndStoreMessage(chatId, `‚úÖ Maximum trade amount set to ${maxAmount} SOL.`);
                        console.log('‚úÖ Max trade amount handling completed successfully');
                        return { handled: true, clearState: true, redirectTo: 'trade_settings' };
                    }
                    case 'waiting_min_trade_amount': {
                        console.log('üîç Processing min trade amount input:', message);
                        const minAmount = parseFloat(message);
                        console.log('üîç Parsed min amount:', minAmount);
                        
                        if (isNaN(minAmount) || minAmount <= 0) {
                            console.log('‚ùå Invalid min trade amount, sending error message');
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid minimum trade amount (positive number).');
                            return { handled: true, clearState: false };
                        }
                        
                        console.log('üîç Getting user by telegram ID:', telegramId);
                        const user = await this.db.getUserByTelegramId(telegramId);
                        console.log('‚úÖ Found user:', user.id);
                        
                        console.log('üîç Updating user settings with min trade amount:', minAmount);
                        await this.db.updateUserSettings(user.id, { min_trade_amount: minAmount });
                        console.log('‚úÖ Settings updated successfully');
                        
                        await this.sendAndStoreMessage(chatId, `‚úÖ Minimum trade amount set to ${minAmount} SOL.`);
                        console.log('‚úÖ Min trade amount handling completed successfully');
                        return { handled: true, clearState: true, redirectTo: 'trade_settings' };
                    }
                    case 'waiting_max_daily_trades': {
                        const maxDaily = parseInt(message);
                        if (isNaN(maxDaily) || maxDaily <= 0) {
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid maximum daily trades (positive integer).');
                            return { handled: true, clearState: false };
                        }
                        const user = await this.db.getUserByTelegramId(telegramId);
                        await this.db.updateUserSettings(user.id, { max_daily_trades: maxDaily });
                        await this.sendAndStoreMessage(chatId, `‚úÖ Maximum daily trades set to ${maxDaily}.`);
                        return { handled: true, clearState: true, redirectTo: 'trade_settings' };
                    }
                    case 'waiting_default_slippage': {
                        console.log('üîç Processing slippage input:', message);
                        try {
                            const slippage = parseFloat(message);
                            console.log('üîç Parsed slippage value:', slippage);
                            
                            if (isNaN(slippage) || slippage < 0 || slippage > 50) {
                                console.log('‚ùå Invalid slippage value, sending error message');
                                await this.sendAndStoreMessage(chatId, '‚ùå Please enter a valid slippage percentage (0-50).\n\nüìä *Common values:*\n‚Ä¢ 0.1-0.5% - Low slippage (may fail in volatile markets)\n‚Ä¢ 1-2% - Standard slippage (recommended)\n‚Ä¢ 3-5% - High slippage (for volatile tokens)\n‚Ä¢ 5-50% - Very high slippage (use with caution)', { parse_mode: 'Markdown' });
                                return { handled: true, clearState: false };
                            }
                            
                            console.log('üîç Getting user by telegram ID:', telegramId);
                            const user = await this.db.getUserByTelegramId(telegramId);
                            if (!user) {
                                console.error('‚ùå User not found for telegram ID:', telegramId);
                                throw new Error('User not found in database');
                            }
                            console.log('‚úÖ Found user:', user.id);
                            
                            console.log('üîç Updating user settings with slippage:', slippage);
                            await this.db.updateUserSettings(user.id, { default_slippage: slippage });
                            console.log('‚úÖ Settings updated successfully');
                            
                            let slippageAdvice = '';
                            if (slippage < 0.5) {
                                slippageAdvice = '\n\nüí° *Low slippage* - Better prices but trades may fail in volatile markets.';
                            } else if (slippage <= 2) {
                                slippageAdvice = '\n\n‚úÖ *Standard slippage* - Good balance of price execution and success rate.';
                            } else if (slippage <= 5) {
                                slippageAdvice = '\n\n‚ö†Ô∏è *High slippage* - More reliable execution but potentially worse prices.';
                            } else {
                                slippageAdvice = '\n\nüö® *Very high slippage* - Use only for highly volatile tokens. Monitor your trades carefully.';
                            }
                            
                            console.log('üîç Sending success message');
                            await this.sendAndStoreMessage(chatId, `‚úÖ Default slippage set to ${slippage}%.${slippageAdvice}`, { parse_mode: 'Markdown' });
                            console.log('‚úÖ Slippage handling completed successfully');
                            return { handled: true, clearState: true, redirectTo: 'trade_settings' };
                        } catch (slippageError) {
                            console.error('‚ùå Error processing slippage input:', slippageError);
                            await this.sendAndStoreMessage(chatId, '‚ùå Sorry, there was an error updating your slippage setting. Please try again.');
                            return { handled: true, clearState: true };
                        }
                    }
                    case 'waiting_stop_loss': {
                        const stopLoss = parseFloat(message);
                        if (isNaN(stopLoss) || stopLoss <= 0 || stopLoss > 100) {
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid stop loss percentage (1-100).');
                            return true;
                        }
                        const user = await this.db.getUserByTelegramId(telegramId);
                        await this.db.updateUserSettings(user.id, { default_stop_loss: stopLoss });
                        await this.sendAndStoreMessage(chatId, `‚úÖ Default stop loss set to ${stopLoss}%.`);
                        return { handled: true, clearState: true, redirectTo: 'risk_settings' };
                    }
                    case 'waiting_take_profit': {
                        const takeProfit = parseFloat(message);
                        if (isNaN(takeProfit) || takeProfit <= 0 || takeProfit > 100) {
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid take profit percentage (1-100).');
                            return true;
                        }
                        const user = await this.db.getUserByTelegramId(telegramId);
                        await this.db.updateUserSettings(user.id, { default_take_profit: takeProfit });
                        await this.sendAndStoreMessage(chatId, `‚úÖ Default take profit set to ${takeProfit}%.`);
                        return { handled: true, clearState: true, redirectTo: 'risk_settings' };
                    }
                    case 'waiting_trail_threshold': {
                        const threshold = parseFloat(message);
                        if (isNaN(threshold) || threshold <= 0 || threshold > 100) {
                            await this.sendAndStoreMessage(chatId, 'Please enter a valid trailing stop threshold percentage (1-100).');
                            return true;
                        }
                        const user = await this.db.getUserByTelegramId(telegramId);
                        await this.db.updateUserSettings(user.id, { trailing_stop_threshold: threshold });
                        await this.sendAndStoreMessage(chatId, `‚úÖ Trailing stop threshold set to ${threshold}%.`);
                        return { handled: true, clearState: true, redirectTo: 'risk_settings' };
                    }
                    default:
                        return false; // Not handled by settings
                }
            }
            console.log('‚ö†Ô∏è No matching user state found or user state is empty');
            console.log('üîç Checking if message looks like a slippage value...');
            
            // Safety check: if the message looks like a slippage value but no state is set,
            // try to handle it anyway (user might have lost state)
            const possibleSlippage = parseFloat(message);
            if (!isNaN(possibleSlippage) && possibleSlippage >= 0 && possibleSlippage <= 50 && message.trim().length <= 5) {
                // Guard: do not hijack if rules flow is active
                try {
                    const rulesStates = this.telegramBotManager?.rulesCommand?.userStates;
                    if (rulesStates && rulesStates.has(telegramId)) {
                        console.log('üõë Skipping slippage auto-handle: rules flow active for user', telegramId);
                        return false;
                    }
                } catch (e) {
                    console.warn('Guard check failed, continuing with caution:', e?.message);
                }
                console.log('üîß Message looks like slippage value, attempting to handle without state...');
                // Set the state and process the message
                if (!this.bot.userStates) {
                    this.bot.userStates = new Map();
                }
                this.bot.userStates.set(telegramId, { state: 'waiting_default_slippage' });
                
                // Recursively call handleMessage with the new state
                const newUserState = this.bot.userStates.get(telegramId);
                return await this.handleMessage(ctx, newUserState);
            }
            
            return false;
        } catch (error) {
            console.error('Error in settingsHandlers.handleMessage:', error);
            
            // Try to send an error message to the user
            try {
                await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while processing your settings input. Please try again.');
            } catch (sendError) {
                console.error('Failed to send error message:', sendError);
            }
            
            // Clear the user state to reset them
            if (this.bot.userStates) {
                this.bot.userStates.delete(telegramId);
            }
            
            return { handled: true, clearState: true };
        }
    }

    async handleSettings(chatId, telegramId) {
        try {
            const message = `
*‚öôÔ∏è Settings*
Manage your bot preferences and wallet settings`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üëõ Wallet Management', callback_data: 'wallet_management' },
                        { text: '‚ö°Ô∏è Trading Settings', callback_data: 'trading_settings' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Main Menu', callback_data: 'main_menu' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading settings.');
        }
    }

    async handleAutonomousToggle(chatId, telegramId, messageId = null) {
        try {
            console.log('handleAutonomousToggle called with:', { chatId, telegramId, messageId });
            console.log('telegramBotManager available:', !!this.telegramBotManager);
            console.log('telegramBotManager showMainMenu method:', typeof this.telegramBotManager?.showMainMenu);
            
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            
            const newStatus = !settings?.autonomous_enabled;
            await this.db.updateUserSettings(user.id, { autonomous_enabled: newStatus });

            // Start/stop autonomous trading process
            if (this.autonomousService) {
                try {
                    if (newStatus) {
                        await this.autonomousService.startAutonomousMode(user.id);
                        console.log('Autonomous trading started for user:', user.id);
                    } else {
                        await this.autonomousService.stopAutonomousMode(user.id);
                        console.log('Autonomous trading stopped for user:', user.id);
                    }
                } catch (autonomousError) {
                    console.error('Error starting/stopping autonomous trading:', autonomousError);
                }
            } else {
                console.warn('AutonomousService instance not available on settings handler.');
            }

            // Delete the previous message if messageId is provided
            if (messageId) {
                try {
                    await this.bot.deleteMessage(chatId, messageId);
                } catch (deleteError) {
                    console.warn('Could not delete previous message:', deleteError.message);
                }
            }

            // Show updated main menu immediately
            const activeWallet = await this.db.getActiveWallet(user.id);
            if (activeWallet) {
                await this.telegramBotManager.showMainMenu(chatId, activeWallet, null, telegramId);
            }

            // Send a brief confirmation message
            const confirmMessage = `ü§ñ Autonomous Trading ${newStatus ? 'Enabled' : 'Disabled'}`;
            const sentMessage = await this.bot.sendMessage(chatId, confirmMessage);
            
            // Delete the confirmation message after 3 seconds
            setTimeout(async () => {
                try {
                    await this.bot.deleteMessage(chatId, sentMessage.message_id);
                } catch (deleteError) {
                    console.warn('Could not delete confirmation message:', deleteError.message);
                }
            }, 3000);

        } catch (error) {
            console.error('Error toggling autonomous trading:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating autonomous trading settings.');
        }
    }

    async handleTradeSettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*üí∞ Trade Settings*

Configure your default trading parameters:

*Current Settings:*
‚Ä¢ Default Slippage: ${settings?.default_slippage || 1}%
‚Ä¢ Max Trade Amount: ${settings?.max_trade_amount || 'Unlimited'}
‚Ä¢ Min Trade Amount: ${settings?.min_trade_amount || '$10'}
‚Ä¢ Max Daily Trades: ${settings?.max_daily_trades || 10}
‚Ä¢ Auto-confirm Trades: ${settings?.auto_confirm ? 'On' : 'Off'}

Select a setting to modify:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üìä Default Slippage', callback_data: 'slippage_presets' },
                        { text: 'üíµ Max Trade Amount', callback_data: 'set_max_trade_amount' }
                    ],
                    [
                        { text: 'üí∞ Min Trade Amount', callback_data: 'set_min_trade_amount' },
                        { text: 'üî¢ Max Daily Trades', callback_data: 'set_max_daily_trades' }
                    ],
                    [
                        { text: '‚ö°Ô∏è Auto-confirm Toggle', callback_data: 'toggle_auto_confirm' },
                        { text: 'üîî Notification Settings', callback_data: 'notification_settings' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing trade settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading trade settings.');
        }
    }

    async handleNotificationSettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*üîî Notification Settings*

Configure when and how you receive notifications:

*Current Settings:*
‚Ä¢ Trade Notifications: ${settings?.notify_on_trade ? 'On' : 'Off'}
‚Ä¢ Profit/Loss Alerts: ${settings?.notify_on_pnl ? 'On' : 'Off'}
‚Ä¢ Rule Triggers: ${settings?.notify_on_rule_trigger ? 'On' : 'Off'}
‚Ä¢ Market Alerts: ${settings?.notify_on_market_alerts ? 'On' : 'Off'}
‚Ä¢ Price Alerts: ${settings?.notify_on_price_alerts ? 'On' : 'Off'}
‚Ä¢ System Updates: ${settings?.notify_on_system_updates ? 'On' : 'Off'}

Select notification types to toggle:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: `${settings?.notify_on_trade ? 'üîï' : 'üîî'} Trade Notifications`, callback_data: 'toggle_trade_notifications' },
                        { text: `${settings?.notify_on_pnl ? 'üîï' : 'üîî'} P&L Alerts`, callback_data: 'toggle_pnl_notifications' }
                    ],
                    [
                        { text: `${settings?.notify_on_rule_trigger ? 'üîï' : 'üîî'} Rule Triggers`, callback_data: 'toggle_rule_notifications' },
                        { text: `${settings?.notify_on_market_alerts ? 'üîï' : 'üîî'} Market Alerts`, callback_data: 'toggle_market_notifications' }
                    ],
                    [
                        { text: `${settings?.notify_on_price_alerts ? 'üîï' : 'üîî'} Price Alerts`, callback_data: 'toggle_price_notifications' },
                        { text: `${settings?.notify_on_system_updates ? 'üîï' : 'üîî'} System Updates`, callback_data: 'toggle_system_notifications' }
                    ],
                    [
                        { text: 'üîï Disable All', callback_data: 'disable_all_notifications' },
                        { text: 'üîî Enable All', callback_data: 'enable_all_notifications' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing notification settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading notification settings.');
        }
    }

    async handleRiskSettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*‚ö†Ô∏è Risk Management Settings*

Configure your risk management parameters:

*Current Settings:*
‚Ä¢ Default Stop Loss: ${settings?.default_stop_loss || 10}%
‚Ä¢ Default Take Profit: ${settings?.default_take_profit || 25}%
‚Ä¢ Trailing Stop: ${settings?.trailing_stop_enabled ? 'Enabled' : 'Disabled'}
‚Ä¢ Trailing Threshold: ${settings?.trailing_stop_threshold || 5}%
‚Ä¢ Max Position Size: ${settings?.max_position_size || 'No limit'}
‚Ä¢ Risk Per Trade: ${settings?.risk_per_trade || 2}%

*Portfolio Limits:*
‚Ä¢ Daily Loss Limit: ${settings?.daily_loss_limit || 'No limit'}
‚Ä¢ Monthly Loss Limit: ${settings?.monthly_loss_limit || 'No limit'}
‚Ä¢ Emergency Stop: ${settings?.emergency_stop_enabled ? 'Enabled' : 'Disabled'}

Select a setting to modify:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üìâ Default Stop Loss', callback_data: 'set_stop_loss' },
                        { text: 'üìà Default Take Profit', callback_data: 'set_take_profit' }
                    ],
                    [
                        { text: 'üîÑ Trailing Stop', callback_data: 'toggle_trailing_stop' },
                        { text: 'üìä Trailing Threshold', callback_data: 'set_trailing_threshold' }
                    ],
                    [
                        { text: 'üí∞ Max Position Size', callback_data: 'set_max_position_size' },
                        { text: '‚ö†Ô∏è Risk Per Trade', callback_data: 'set_risk_per_trade' }
                    ],
                    [
                        { text: 'üö® Daily Loss Limit', callback_data: 'set_daily_loss_limit' },
                        { text: 'üõë Emergency Stop', callback_data: 'toggle_emergency_stop' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing risk settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading risk settings.');
        }
    }

    async handleStrategySettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*üìä Strategy Settings*

Configure default strategy parameters:

*Algorithm Settings:*
‚Ä¢ Strategy Aggressiveness: ${settings?.strategy_aggressiveness || 'Medium'}
‚Ä¢ Market Analysis Depth: ${settings?.analysis_depth || 'Standard'}
‚Ä¢ Signal Confidence Threshold: ${settings?.signal_threshold || 70}%
‚Ä¢ Multi-timeframe Analysis: ${settings?.multi_timeframe ? 'Enabled' : 'Disabled'}

*Execution Settings:*
‚Ä¢ Order Type: ${settings?.default_order_type || 'Market'}
‚Ä¢ Execution Speed: ${settings?.execution_speed || 'Fast'}
‚Ä¢ Partial Fill Handling: ${settings?.partial_fill_handling || 'Allow'}
‚Ä¢ Retry Failed Orders: ${settings?.retry_failed_orders ? 'Enabled' : 'Disabled'}

Select a setting to configure:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üéØ Strategy Aggressiveness', callback_data: 'set_strategy_aggressiveness' },
                        { text: 'üîç Analysis Depth', callback_data: 'set_analysis_depth' }
                    ],
                    [
                        { text: 'üìä Signal Threshold', callback_data: 'set_signal_threshold' },
                        { text: '‚è∞ Multi-timeframe', callback_data: 'toggle_multi_timeframe' }
                    ],
                    [
                        { text: 'üìã Order Type', callback_data: 'set_order_type' },
                        { text: '‚ö°Ô∏è Execution Speed', callback_data: 'set_execution_speed' }
                    ],
                    [
                        { text: 'üîÑ Retry Orders', callback_data: 'toggle_retry_orders' },
                        { text: 'üìà Performance Metrics', callback_data: 'view_performance_metrics' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing strategy settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading strategy settings.');
        }
    }

    async handleAdvancedSettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*üîß Advanced Settings*

Configure advanced bot features:

*API & Performance:*
‚Ä¢ API Rate Limiting: ${settings?.api_rate_limiting ? 'Enabled' : 'Disabled'}
‚Ä¢ Cache Duration: ${settings?.cache_duration || 30} seconds
‚Ä¢ Concurrent Requests: ${settings?.max_concurrent_requests || 5}
‚Ä¢ Request Timeout: ${settings?.request_timeout || 10} seconds

*Security:*
‚Ä¢ Two-Factor Authentication: ${settings?.tfa_enabled ? 'Enabled' : 'Disabled'}
‚Ä¢ Session Timeout: ${settings?.session_timeout || 24} hours
‚Ä¢ IP Whitelist: ${settings?.ip_whitelist_enabled ? 'Enabled' : 'Disabled'}
‚Ä¢ Encryption Level: ${settings?.encryption_level || 'AES-256'}

*Debug & Logs:*
‚Ä¢ Verbose Logging: ${settings?.verbose_logging ? 'Enabled' : 'Disabled'}
‚Ä¢ Trade Logging: ${settings?.trade_logging ? 'Enabled' : 'Disabled'}
‚Ä¢ Error Reporting: ${settings?.error_reporting ? 'Enabled' : 'Disabled'}

‚ö†Ô∏è *Warning:* Only modify these settings if you understand their impact.`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üîí Security Settings', callback_data: 'advanced_security_settings' },
                        { text: '‚ö°Ô∏è Performance Settings', callback_data: 'advanced_performance_settings' }
                    ],
                    [
                        { text: 'üìù Logging Settings', callback_data: 'advanced_logging_settings' },
                        { text: 'üîß API Settings', callback_data: 'advanced_api_settings' }
                    ],
                    [
                        { text: 'üîÑ Reset to Defaults', callback_data: 'reset_advanced_settings' },
                        { text: 'üìä System Diagnostics', callback_data: 'system_diagnostics' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing advanced settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading advanced settings.');
        }
    }

    async handleInterfaceSettings(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);

            const message = `
*üì± Interface Settings*

Customize your bot interface:

*Display Settings:*
‚Ä¢ Theme: ${settings?.theme || 'Default'}
‚Ä¢ Language: ${settings?.language || 'English'}
‚Ä¢ Timezone: ${settings?.timezone || 'UTC'}
‚Ä¢ Number Format: ${settings?.number_format || 'US'}

*Message Settings:*
‚Ä¢ Message Length: ${settings?.message_length || 'Standard'}
‚Ä¢ Show Emojis: ${settings?.show_emojis ? 'Yes' : 'No'}
‚Ä¢ Show Advanced Info: ${settings?.show_advanced_info ? 'Yes' : 'No'}
‚Ä¢ Auto-delete Messages: ${settings?.auto_delete_messages ? 'Enabled' : 'Disabled'}

*Keyboard Layout:*
‚Ä¢ Button Size: ${settings?.button_size || 'Medium'}
‚Ä¢ Quick Actions: ${settings?.quick_actions_enabled ? 'Enabled' : 'Disabled'}
‚Ä¢ Keyboard Layout: ${settings?.keyboard_layout || 'Standard'}

Select an option to customize:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üé® Theme Settings', callback_data: 'set_theme' },
                        { text: 'üåç Language & Region', callback_data: 'set_language_region' }
                    ],
                    [
                        { text: 'üí¨ Message Settings', callback_data: 'set_message_settings' },
                        { text: '‚å®Ô∏è Keyboard Layout', callback_data: 'set_keyboard_layout' }
                    ],
                    [
                        { text: '‚ö°Ô∏è Quick Actions', callback_data: 'configure_quick_actions' },
                        { text: 'üïí Auto-delete Timer', callback_data: 'set_auto_delete_timer' }
                    ],
                    [
                        { text: 'üîÑ Reset Interface', callback_data: 'reset_interface_settings' },
                        { text: 'üëÄ Preview Changes', callback_data: 'preview_interface' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing interface settings:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading interface settings.');
        }
    }

    // Settings value handlers
    async handleDefaultSlippage(chatId, telegramId) {
        console.log('üöÄ handleDefaultSlippage called for user:', telegramId);
        try {
            // Initialize userStates if it doesn't exist
            if (!this.bot.userStates) {
                console.log('üîç Initializing userStates Map');
                this.bot.userStates = new Map();
            }
            
            console.log('üîç Setting user state to waiting_default_slippage');
            this.bot.userStates.set(telegramId, { state: 'waiting_default_slippage' });
            console.log('üîç User state set:', this.bot.userStates.get(telegramId));
            
            const currentSlippage = await this.getCurrentSlippage(telegramId);
            console.log('üîç Current slippage:', currentSlippage);
            
            const message = `*üìä Set Default Slippage*\n\nEnter your preferred default slippage percentage (e.g. 0.5, 1, 2):\n\nüí° *Tips:*\n‚Ä¢ Lower slippage (0.1-0.5%): Better price execution, higher chance of failed trades\n‚Ä¢ Higher slippage (1-3%): More reliable execution, potentially worse prices\n‚Ä¢ Very high slippage (>5%): Only for highly volatile tokens\n\n*Current slippage:* ${currentSlippage}%`;
            
            console.log('üîç Sending slippage setup message');
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown' });
            console.log('‚úÖ Slippage setup message sent successfully');
        } catch (error) {
            console.error('‚ùå Error in handleDefaultSlippage:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up slippage configuration.');
        }
    }

    async handleMaxTradeAmount(chatId, telegramId) {
        console.log('üöÄ handleMaxTradeAmount called for user:', telegramId);
        try {
            if (!this.bot.userStates) {
                console.log('üîç Initializing userStates Map');
                this.bot.userStates = new Map();
            }
            
            console.log('üîç Setting user state to waiting_max_trade_amount');
            this.bot.userStates.set(telegramId, { state: 'waiting_max_trade_amount' });
            console.log('üîç User state set:', this.bot.userStates.get(telegramId));
            
            const message = `*üíµ Set Maximum Trade Amount*\n\nEnter your maximum trade amount in SOL (e.g. 1, 5, 10):`;
            
            console.log('üîç Sending max trade amount setup message');
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown' });
            console.log('‚úÖ Max trade amount setup message sent successfully');
        } catch (error) {
            console.error('‚ùå Error in handleMaxTradeAmount:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up trade amount configuration.');
        }
    }

    async handleMinTradeAmount(chatId, telegramId) {
        console.log('üöÄ handleMinTradeAmount called for user:', telegramId);
        try {
            if (!this.bot.userStates) {
                console.log('üîç Initializing userStates Map');
                this.bot.userStates = new Map();
            }
            
            console.log('üîç Setting user state to waiting_min_trade_amount');
            this.bot.userStates.set(telegramId, { state: 'waiting_min_trade_amount' });
            console.log('üîç User state set:', this.bot.userStates.get(telegramId));
            
            const message = `*üí∞ Set Minimum Trade Amount*\n\nEnter your minimum trade amount in SOL (e.g. 0.1, 1):`;
            
            console.log('üîç Sending min trade amount setup message');
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown' });
            console.log('‚úÖ Min trade amount setup message sent successfully');
        } catch (error) {
            console.error('‚ùå Error in handleMinTradeAmount:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up trade amount configuration.');
        }
    }

    async handleMaxDailyTrades(chatId, telegramId) {
        console.log('üöÄ handleMaxDailyTrades called for user:', telegramId);
        try {
            if (!this.bot.userStates) {
                console.log('üîç Initializing userStates Map');
                this.bot.userStates = new Map();
            }
            
            console.log('üîç Setting user state to waiting_max_daily_trades');
            this.bot.userStates.set(telegramId, { state: 'waiting_max_daily_trades' });
            console.log('üîç User state set:', this.bot.userStates.get(telegramId));
            
            const message = `*üî¢ Set Maximum Daily Trades*\n\nEnter your maximum number of trades per day (e.g. 5, 10, 20):`;
            
            console.log('üîç Sending max daily trades setup message');
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown' });
            console.log('‚úÖ Max daily trades setup message sent successfully');
        } catch (error) {
            console.error('‚ùå Error in handleMaxDailyTrades:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up daily trades configuration.');
        }
    }

    async handleAutoConfirmToggle(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.auto_confirm;
            await this.db.updateUserSettings(user.id, { auto_confirm: newStatus });
            const message = `\n*‚ö°Ô∏è Auto-confirm Trades ${newStatus ? 'Enabled' : 'Disabled'}*\n\n${newStatus ? '‚úÖ Trades will now be executed automatically without confirmation prompts.' : '‚ùå You will now be asked to confirm each trade before execution.'}\n\n${newStatus ? '‚ö†Ô∏è Make sure your risk management settings are properly configured.' : 'üí° This gives you more control but may slow down execution in fast markets.'}`;
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: '‚óÄÔ∏è Back to Settings', callback_data: 'settings' }
                    ]
                ]
            };
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown', reply_markup: keyboard });
        } catch (error) {
            console.error('Error toggling auto-confirm:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating auto-confirm settings.');
        }
    }

    // Quick slippage presets
    async handleSlippagePresets(chatId, telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const currentSlippage = settings?.default_slippage || 1;

            const message = `*üìä Quick Slippage Presets*\n\nCurrent slippage: ${currentSlippage}%\n\nChoose a preset or select 'Custom' to enter your own value:`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üü¢ Low (0.5%)', callback_data: 'preset_slippage_0.5' },
                        { text: 'üîµ Standard (1%)', callback_data: 'preset_slippage_1' }
                    ],
                    [
                        { text: 'üü° Medium (2%)', callback_data: 'preset_slippage_2' },
                        { text: 'üü† High (3%)', callback_data: 'preset_slippage_3' }
                    ],
                    [
                        { text: 'üî¥ Very High (5%)', callback_data: 'preset_slippage_5' },
                        { text: '‚öôÔ∏è Custom', callback_data: 'set_default_slippage' }
                    ],
                    [
                        { text: '‚óÄÔ∏è Back to Trade Settings', callback_data: 'trade_settings' }
                    ]
                ]
            };

            await this.sendAndStoreMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        } catch (error) {
            console.error('Error showing slippage presets:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading slippage presets.');
        }
    }

    // Handler for custom slippage input (triggered by 'set_default_slippage' callback)
    async handleSetDefaultSlippage(chatId, telegramId) {
        try {
            if (!this.bot.userStates) {
                this.bot.userStates = new Map();
            }
            this.bot.userStates.set(telegramId, { state: 'waiting_default_slippage' });
            const message = `*üìä Enter Custom Slippage*\n\nPlease enter your preferred slippage percentage (e.g. 0.5, 1, 2):`;
            await this.sendAndStoreMessage(chatId, message, { parse_mode: 'Markdown' });
        } catch (error) {
            console.error('Error in handleSetDefaultSlippage:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up custom slippage input.');
        }
    }

    // Handle slippage preset selection
    async handleSlippagePreset(chatId, telegramId, slippageValue) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            await this.db.updateUserSettings(user.id, { default_slippage: slippageValue });
            
            let slippageAdvice = '';
            if (slippageValue < 0.5) {
                slippageAdvice = '\n\nüí° *Low slippage* - Better prices but trades may fail in volatile markets.';
            } else if (slippageValue <= 2) {
                slippageAdvice = '\n\n‚úÖ *Standard slippage* - Good balance of price execution and success rate.';
            } else if (slippageValue <= 5) {
                slippageAdvice = '\n\n‚ö†Ô∏è *High slippage* - More reliable execution but potentially worse prices.';
            } else {
                slippageAdvice = '\n\nüö® *Very high slippage* - Use only for highly volatile tokens. Monitor your trades carefully.';
            }

            await this.sendAndStoreMessage(chatId, `‚úÖ Default slippage set to ${slippageValue}%.${slippageAdvice}`);
            
            // Return to trade settings after 2 seconds
            setTimeout(async () => {
                await this.handleTradeSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('Error setting slippage preset:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting the slippage preset.');
        }
    }

    // Helper method to get current slippage
    async getCurrentSlippage(telegramId) {
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            return settings?.default_slippage || 1;
        } catch (error) {
            console.error('Error getting current slippage:', error);
            return 1; // Default fallback
        }
    }

    async sendAndStoreMessage(chatId, message, options = {}) {
        return await TelegramErrorHandler.sendMessage(this.bot, chatId, message, options, this.lastMessageIds);
    }

    // Notification toggle handlers
    async handleTradeNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handleTradeNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_trade;
            
            console.log('üîç Current trade notification status:', settings?.notify_on_trade);
            console.log('üîç New trade notification status:', newStatus);
            
            await this.db.updateUserSettings(user.id, { notify_on_trade: newStatus });
            
            const message = `‚úÖ Trade notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
            
            console.log('‚úÖ Trade notifications toggle completed successfully');
        } catch (error) {
            console.error('‚ùå Error toggling trade notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating trade notification settings.');
        }
    }

    async handlePnlNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handlePnlNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_pnl;
            
            await this.db.updateUserSettings(user.id, { notify_on_pnl: newStatus });
            
            const message = `‚úÖ P&L notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error toggling P&L notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating P&L notification settings.');
        }
    }

    async handleRuleNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handleRuleNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_rule_trigger;
            
            await this.db.updateUserSettings(user.id, { notify_on_rule_trigger: newStatus });
            
            const message = `‚úÖ Rule trigger notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error toggling rule notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating rule notification settings.');
        }
    }

    async handleMarketNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handleMarketNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_market_alerts;
            
            await this.db.updateUserSettings(user.id, { notify_on_market_alerts: newStatus });
            
            const message = `‚úÖ Market alert notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error toggling market notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating market notification settings.');
        }
    }

    async handlePriceNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handlePriceNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_price_alerts;
            
            await this.db.updateUserSettings(user.id, { notify_on_price_alerts: newStatus });
            
            const message = `‚úÖ Price alert notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error toggling price notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating price notification settings.');
        }
    }

    async handleSystemNotificationsToggle(chatId, telegramId) {
        console.log('üöÄ handleSystemNotificationsToggle called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            const settings = await this.db.getUserSettings(user.id);
            const newStatus = !settings?.notify_on_system_updates;
            
            await this.db.updateUserSettings(user.id, { notify_on_system_updates: newStatus });
            
            const message = `‚úÖ System update notifications ${newStatus ? 'enabled' : 'disabled'}.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error toggling system notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while updating system notification settings.');
        }
    }

    async handleDisableAllNotifications(chatId, telegramId) {
        console.log('üöÄ handleDisableAllNotifications called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            
            await this.db.updateUserSettings(user.id, {
                notify_on_trade: false,
                notify_on_pnl: false,
                notify_on_rule_trigger: false,
                notify_on_market_alerts: false,
                notify_on_price_alerts: false,
                notify_on_system_updates: false
            });
            
            const message = `üîï All notifications disabled.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error disabling all notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while disabling notifications.');
        }
    }

    async handleEnableAllNotifications(chatId, telegramId) {
        console.log('üöÄ handleEnableAllNotifications called for user:', telegramId);
        try {
            const user = await this.db.getUserByTelegramId(telegramId);
            
            await this.db.updateUserSettings(user.id, {
                notify_on_trade: true,
                notify_on_pnl: true,
                notify_on_rule_trigger: true,
                notify_on_market_alerts: true,
                notify_on_price_alerts: true,
                notify_on_system_updates: true
            });
            
            const message = `üîî All notifications enabled.`;
            await this.sendAndStoreMessage(chatId, message);
            
            // Return to notification settings after 2 seconds
            setTimeout(async () => {
                await this.handleNotificationSettings(chatId, telegramId);
            }, 2000);
        } catch (error) {
            console.error('‚ùå Error enabling all notifications:', error);
            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while enabling notifications.');
        }
    }
}

module.exports = SettingsHandlers;
